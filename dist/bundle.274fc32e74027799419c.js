"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[759],{759:(t,e,n)=>{n.r(e);var o=n(477),i=n(946);function r(t){let e,n,i,r=0;for(let o=0;o<t.length;++o){const a=t[o];if(a.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(void 0===e&&(e=a.array.constructor),e!==a.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(void 0===n&&(n=a.itemSize),n!==a.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(void 0===i&&(i=a.normalized),i!==a.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;r+=a.array.length}const a=new e(r);let s=0;for(let e=0;e<t.length;++e)a.set(t[e].array,s),s+=t[e].array.length;return new o.TlE(a,n,i)}const a={bounceFactor:.03,wobbleFactor:10,maxTranslation:.05,maxRotationDegrees:Math.PI/180*5,maxStretch:1},s=new o.Aip(.01);s.translate(0,-.005,0);const l=new o.m_w(0,.01,.1,4,1);l.translate(0,.05,0);const c=function(t,e=!1){const n=null!==t[0].index,i=new Set(Object.keys(t[0].attributes)),a=new Set(Object.keys(t[0].morphAttributes??t[0])),s={},l={},c=t[0].morphTargetsRelative,h=new o.u9r;let u=0;for(let o=0;o<t.length;++o){const r=t[o];let d=0;if(n!==(null!==r.index))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const t in r.attributes){if(!i.has(t))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.'),null;void 0===s[t]&&(s[t]=[]),s[t].push(r.attributes[t]),d++}if(d!==i.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". Make sure all geometries have the same number of attributes."),null;if(c!==r.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const t in r.morphAttributes){if(!a.has(t))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+".  .morphAttributes must be consistent throughout all geometries."),null;void 0===l[t]&&(l[t]=[]),l[t].push(r.morphAttributes[t])}if(h.userData.mergedUserData=h.userData.mergedUserData||[],h.userData.mergedUserData.push(r.userData),e){let t;if(n)t=r.index.count;else{if(void 0===r.attributes.position)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+o+". The geometry must have either an index or a position attribute"),null;t=r.attributes.position.count}h.addGroup(u,t,o),u+=t}}if(n){let e=0;const n=[];for(let o=0;o<t.length;++o){const i=t[o].index;for(let t=0;t<i.count;++t)n.push(i.getX(t)+e);e+=t[o].attributes.position.count}h.setIndex(n)}for(const t in s){const e=r(s[t]);if(!e)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" attribute."),null;h.setAttribute(t,e)}for(const t in l){const e=l[t][0].length;if(0===e)break;h.morphAttributes=h.morphAttributes||{},h.morphAttributes[t]=[];for(let n=0;n<e;++n){const e=[];for(let o=0;o<l[t].length;++o)e.push(l[t][o][n]);const o=r(e);if(!o)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+t+" morphAttribute."),null;h.morphAttributes[t].push(o)}}return h}([s,l]);c.rotateX(Math.PI/2);const h=new o.Kj0(new o.xo$(.03),new o.vBJ({color:"blue",depthTest:!1,transparent:!0,visible:!1,toneMapped:!1}));h.renderOrder=999;const u=new o.Kj0(c,new o.vBJ({color:"yellow",depthTest:!1,transparent:!0,opacity:.1,visible:!1,toneMapped:!1}));u.renderOrder=9999;const d=new o.Kj0(new o.xo$(.02),new o.vBJ({color:"yellow",depthTest:!1,transparent:!0,opacity:.1,visible:!1,toneMapped:!1}));d.renderOrder=999,new o.Pa4,new o._fP;const p=new o.Pa4;new o._fP;class g{constructor(t,e={}){this.options={...a,...e},this.target=t,this.targetHelper=h.clone(),e.scene&&e.scene.add(this.targetHelper),this.currentHelper=u.clone(),e.scene&&e.scene.add(this.currentHelper),this.currentHelper.add(d.clone()),this.currentHelper.children[0].position.y=-.1,this.originPosition=t.position.clone(),this.oldBoneWorldPosition=new o.Pa4,this.oldBoneWorldRotation=new o._fP,this.target.getWorldPosition(this.oldBoneWorldPosition),this.target.getWorldQuaternion(this.oldBoneWorldRotation)}reset(){this.target.position.copy(this.originPosition),this.target.updateMatrixWorld(!0,!1),this.target.getWorldPosition(this.oldBoneWorldPosition)}update(t){this.target.parent.updateMatrixWorld(!0,!1),this.targetHelper.position.copy(this.originPosition),this.target.parent.localToWorld(this.targetHelper.position),v(p,this.oldBoneWorldPosition,this.targetHelper.position,this.options.bounceFactor*t),t>10&&v(p,this.oldBoneWorldPosition,this.targetHelper.position,this.options.bounceFactor*t),this.target.position.copy(p),this.target.parent.worldToLocal(this.target.position),this.oldBoneWorldPosition.copy(p);const e=this.target.parent.getWorldPosition(new o.Pa4);this.currentHelper.position.copy(p),this.currentHelper.updateMatrixWorld(!0,!1),this.currentHelper.lookAt(e),this.currentHelper.children[0].getWorldPosition(new o.Pa4);const n=this.target.position.clone();n.normalize(),this.target.up.set(0,1,0),this.target.quaternion.setFromUnitVectors(this.target.up,n);let i=Math.min(this.target.position.length(),this.options.maxStretch);this.target.position.set(0,i,0),this.target.updateMatrix()}}const f=new o.Pa4;o.Pa4.prototype.moveTowards=function(t,e){f.copy(t).sub(this);const n=(o=e,0,i=f.length(),Math.min(i,Math.max(0,o)));var o,i;f.setLength(n),this.add(f)},new o.Pa4;const m=new o.Pa4;function v(t,e,n,o){const i=e.length(),r=n.length();var a;m.copy(n).normalize(),t.copy(e).normalize().lerp(m,o).normalize().multiplyScalar((a=i)+o*(r-a))}var w=n(217),b=n(365);const y={width:window.innerWidth,height:window.innerHeight},x=new o.FM8;window.addEventListener("mousemove",(t=>{x.x=t.clientX/y.width*2-1,x.y=-t.clientY/y.height*2+1}));const E=document.querySelector("canvas"),P=new o.xsS,M=new o.dpR,B=(new o.cBK).load(["./textures/environmentMaps/cubeMap/px.jpg","./textures/environmentMaps/cubeMap/nx.jpg","./textures/environmentMaps/cubeMap/py.jpg","./textures/environmentMaps/cubeMap/ny.jpg","./textures/environmentMaps/cubeMap/pz.jpg","./textures/environmentMaps/cubeMap/nz.jpg"]),R=new o.jyz({uniforms:{turbidity:{value:2.5},rayleigh:{value:2.7},mieCoefficient:{value:.218},mieDirectionalG:{value:.23},elevation:{value:-18},azimuth:{value:0},sunPosition:{value:new o.Pa4(o.M8C.degToRad(108),o.M8C.degToRad(0),1)},up:{value:new o.Pa4(0,1,0)}},vertexShader:"\n\t\tuniform vec3 sunPosition;\n\t\tuniform float rayleigh;\n\t\tuniform float turbidity;\n\t\tuniform float mieCoefficient;\n\t\tuniform vec3 up;\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\t// constants for atmospheric scattering\n\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\t// wavelength of used primaries, according to preetham\n\t\tconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\tconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\tconst float v = 4.0;\n\t\tconst vec3 K = vec3( 0.686, 0.678, 0.666 );\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\tconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\tconst float cutoffAngle = 1.6110731556870734;\n\t\tconst float steepness = 1.5;\n\t\tconst float EE = 1000.0;\n\n\t\tfloat sunIntensity( float zenithAngleCos ) {\n\t\t\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n\t\t\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n\t\t}\n\n\t\tvec3 totalMie( float T ) {\n\t\t\tfloat c = ( 0.2 * T ) * 10E-18;\n\t\t\treturn 0.434 * c * MieConst;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n      worldPosition.y *= -1.0;\n\t\t\tvWorldPosition = worldPosition.xyz;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n\t\t\tvSunDirection = normalize( sunPosition );\n\n\t\t\tvSunE = sunIntensity( dot( vSunDirection, up ) );\n\n\t\t\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n\t\t\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n\t\t\t// extinction (absorbtion + out scattering)\n\t\t\t// rayleigh coefficients\n\t\t\tvBetaR = totalRayleigh * rayleighCoefficient;\n\n\t\t\t// mie coefficients\n\t\t\tvBetaM = totalMie( turbidity ) * mieCoefficient;\n\n\t\t}",fragmentShader:"\n    #include <common>\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n    vec3 dithering( vec3 color ) {\n  \t\tfloat grid_position = rand( gl_FragCoord.xy );\n  \t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n  \t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n  \t\treturn color + dither_shift_RGB;\n  \t}\n\n\t\tuniform float mieDirectionalG;\n\t\tuniform vec3 up;\n\n\t\tconst vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n\t\t// constants for atmospheric scattering\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\tconst float n = 1.0003; // refractive index of air\n\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\tconst float rayleighZenithLength = 8.4E3;\n\t\tconst float mieZenithLength = 1.25E3;\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\tconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n\t\t// 1.0 / ( 4.0 * pi )\n\t\tconst float ONE_OVER_FOURPI = 0.07957747154594767;\n\n\t\tfloat rayleighPhase( float cosTheta ) {\n\t\t\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n\t\t}\n\n\t\tfloat hgPhase( float cosTheta, float g ) {\n\t\t\tfloat g2 = pow( g, 2.0 );\n\t\t\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n\t\t\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec3 direction = normalize( vWorldPosition - cameraPos );\n\n\t\t\t// optical length\n\t\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n\t\t\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n\t\t\tfloat sR = rayleighZenithLength * inverse;\n\t\t\tfloat sM = mieZenithLength * inverse;\n\n\t\t\t// combined extinction factor\n\t\t\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n\t\t\t// in scattering\n\t\t\tfloat cosTheta = dot( direction, vSunDirection );\n\n\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\t\t\tvec3 betaRTheta = vBetaR * rPhase;\n\n\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\t\t\tvec3 betaMTheta = vBetaM * mPhase;\n\n\t\t\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n\t\t\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n\t\t\t// nightsky\n\t\t\tfloat theta = acos( direction.y ); // elevation --\x3e y-axis, [-pi/2, pi/2]\n\t\t\tfloat phi = atan( direction.z, direction.x ); // azimuth --\x3e x-axis [-pi/2, pi/2]\n\t\t\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n\t\t\tvec3 L0 = vec3( 0.1 ) * Fex;\n\n\t\t\t// composition + solar disc\n\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\t\t\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n\t\t\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n\t\t\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n\t\t\tgl_FragColor = vec4( retColor, 1.0 );\n\n      gl_FragColor.rgb += 0.05;\n      vec3 desaurated =  gl_FragColor.rgb / 0.21 * gl_FragColor.r + 0.71 * gl_FragColor.g + 0.07 * gl_FragColor.b;\n      desaurated -= 0.023;\n      gl_FragColor.rgb = mix(gl_FragColor.rgb, desaurated, 0.95);\n      gl_FragColor.rgb = dithering(gl_FragColor.rgb);\n\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}",side:o._Li,depthWrite:!1}),S=new o.DvJ(20,20,20),T=new o.Kj0(S,R);T.scale.setScalar(100),P.add(T);const _=M.load("./textures/environmentMaps/normal.jpeg");_.wrapS=o.rpg,_.wrapT=o.rpg,_.repeat.set(1,1);const C=new o.EJi({transmission:1,thickness:1.2,roughness:.05,envMap:B,envMapIntensity:1.5,clearcoat:1,clearcoatRoughness:.1,normalScale:new o.FM8(1),normalMap:_,clearcoatNormalMap:_,clearcoatNormalScale:new o.FM8(.3)}),z=new w.E,A=new i.v2;function F(t,e){e.matrix.copy(t.worldMatrix)}const H=new o.b_z(.6,1,3);H.translate(0,.51,0);const G=new o.RSm,W=new o.Kj0(H,G);W.castShadow=!0,W.receiveShadow=!0,W.position.set(3,-1,3),P.add(W);const D=new i.xJ;let j,k,U,I;D.setRenderComponent(W,F),D.position.set(3,0,3),D.maxSpeed=2,A.add(D);let L=!1;z.load("./models/fork.glb",(t=>{const e=t.scene.children[0];e.position.set(0,3,0),P.add(e),j=P.getObjectByName("Fork"),((t,e)=>{t.traverse((t=>{t.isMesh&&(t.material=e,t.castShadow=!0)}))})(j,C),U=j.children.find((t=>t.isBone)),k=new i.xJ,k.setRenderComponent(U,F),k.maxSpeed=3,A.add(k),new i.F(D.position);const n=new i.af(D,1);k.steering.add(n),I=[],U.traverse((t=>{if("Root"!==t.name&&(t.isBone&&t.name.match("Leg")||t.name.match("Head"))){const e=t.name.match("Head")?{bounceFactor:10,maxStretch:1}:{bounceFactor:5,maxStretch:2};I.push(new g(t,{...e,scene:P}))}})),L=!0}));const O=new o.Mig(6317429,.4),K=new o.Ox3(16777215,.2);K.position.set(0,100,0),K.castShadow=!0,K.receiveShadow=!0,K.shadow.mapSize.width=2048,K.shadow.mapSize.height=2048,K.shadow.camera.top=10,K.shadow.camera.left=-10,K.shadow.camera.right=10,K.shadow.camera.bottom=-10,K.shadow.camera.near=.5,K.shadow.camera.far=102,new o.cBI(K),new o.Rki(K.shadow.camera).visible=!0,P.add(O,K);const N=new o._12(20,20,32,32),J=new o.Wid({color:2698035,side:o.ehD}),V=new o.Kj0(N,J);V.position.set(0,-1,0),V.rotation.x=.5*-Math.PI,V.receiveShadow=!0,P.add(V);const Z=new o.cPb(20,y.width/y.height,.1,100);Z.position.set(18,36,18),Z.rotation.x=Math.PI/4,P.add(Z);const X=new b.z(Z,E);X.enableDamping=!0,X.maxPolarAngle=Math.PI/2,X.enableZoom=!1;const q=new o.CP7({canvas:E,antialiased:!1,logarithmicDepthBuffer:!0,powerPreference:"high-performance"});q.setClearColor(0,1),q.setSize(y.width,y.height),q.setPixelRatio(Math.min(window.devicePixelRatio,2)),q.physicallyCorrectLights=!0,q.outputEncoding=o.knz,q.setSize(y.width,y.height),q.shadowMap.type=o.ntZ,q.shadowMap.enabled=!0;const Y=new o.iMs;window.addEventListener("resize",(()=>{y.width=window.innerWidth,y.height=window.innerHeight,Z.aspect=y.width/y.height,Z.updateProjectionMatrix(),q.setSize(y.width,y.height),q.setPixelRatio(Math.min(window.devicePixelRatio,2))}));const $=new o.SUY;let Q=0;const tt=()=>{const t=$.getElapsedTime(),e=t-Q;Q=t;let n=Y.intersectObject(V);Y.setFromCamera(x,Z),A.update(e),L&&(n.length>0&&(D.position.copy(n[0].point),W.position.copy(D.position)),U.position.copy(k.position),U.rotation.y+=.033,A.update(e),I.forEach(((t,n)=>{t.update(e)}))),X.update(),q.render(P,Z),window.requestAnimationFrame(tt)};tt()}}]);
//# sourceMappingURL=bundle.274fc32e74027799419c.js.map