{"version":3,"file":"bundle.29966a2f901a8d5dd391.js","mappings":"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","sources":["webpack:///./src/utils/BufferGeometryUtils.js","webpack:///./src/utils/WiggleBones.js","webpack:///./src/utils/math.js","webpack:///./src/App.js"],"sourcesContent":["import {\n    BufferAttribute,\n    BufferGeometry,\n    Float32BufferAttribute,\n    InterleavedBuffer,\n    InterleavedBufferAttribute,\n    TriangleFanDrawMode,\n    TriangleStripDrawMode,\n    TrianglesDrawMode,\n    Vector3\n} from 'three';\n\n\nfunction computeTangents(geometry) {\n\n    geometry.computeTangents();\n    console.warn('THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.');\n\n}\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nfunction mergeBufferGeometries(geometries, useGroups = false) {\n\n    const isIndexed = geometries[0].index !== null;\n    \n    const attributesUsed = new Set(Object.keys(geometries[0].attributes));\n    const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes ?? geometries[0]));\n\n    const attributes = {};\n    const morphAttributes = {};\n\n    const morphTargetsRelative = geometries[0].morphTargetsRelative;\n\n    const mergedGeometry = new BufferGeometry();\n\n    let offset = 0;\n\n    for (let i = 0; i < geometries.length; ++i) {\n\n        const geometry = geometries[i];\n        let attributesCount = 0;\n\n        // ensure that all geometries are indexed, or none\n\n        if (isIndexed !== (geometry.index !== null)) {\n\n            console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');\n            return null;\n\n        }\n\n        // gather attributes, exit early if they're different\n\n        for (const name in geometry.attributes) {\n\n            if (!attributesUsed.has(name)) {\n\n                console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.');\n                return null;\n\n            }\n\n            if (attributes[name] === undefined) attributes[name] = [];\n\n            attributes[name].push(geometry.attributes[name]);\n\n            attributesCount++;\n\n        }\n\n        // ensure geometries have the same number of attributes\n\n        if (attributesCount !== attributesUsed.size) {\n\n            console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');\n            return null;\n\n        }\n\n        // gather morph attributes, exit early if they're different\n\n        if (morphTargetsRelative !== geometry.morphTargetsRelative) {\n\n            console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');\n            return null;\n\n        }\n\n        for (const name in geometry.morphAttributes) {\n\n            if (!morphAttributesUsed.has(name)) {\n\n                console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');\n                return null;\n\n            }\n\n            if (morphAttributes[name] === undefined) morphAttributes[name] = [];\n\n            morphAttributes[name].push(geometry.morphAttributes[name]);\n\n        }\n\n        // gather .userData\n\n        mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n        mergedGeometry.userData.mergedUserData.push(geometry.userData);\n\n        if (useGroups) {\n\n            let count;\n\n            if (isIndexed) {\n\n                count = geometry.index.count;\n\n            } else if (geometry.attributes.position !== undefined) {\n\n                count = geometry.attributes.position.count;\n\n            } else {\n\n                console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');\n                return null;\n\n            }\n\n            mergedGeometry.addGroup(offset, count, i);\n\n            offset += count;\n\n        }\n\n    }\n\n    // merge indices\n\n    if (isIndexed) {\n\n        let indexOffset = 0;\n        const mergedIndex = [];\n\n        for (let i = 0; i < geometries.length; ++i) {\n\n            const index = geometries[i].index;\n\n            for (let j = 0; j < index.count; ++j) {\n\n                mergedIndex.push(index.getX(j) + indexOffset);\n\n            }\n\n            indexOffset += geometries[i].attributes.position.count;\n\n        }\n\n        mergedGeometry.setIndex(mergedIndex);\n\n    }\n\n    // merge attributes\n\n    for (const name in attributes) {\n\n        const mergedAttribute = mergeBufferAttributes(attributes[name]);\n\n        if (!mergedAttribute) {\n\n            console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.');\n            return null;\n\n        }\n\n        mergedGeometry.setAttribute(name, mergedAttribute);\n\n    }\n\n    // merge morph attributes\n\n    for (const name in morphAttributes) {\n\n        const numMorphTargets = morphAttributes[name][0].length;\n\n        if (numMorphTargets === 0) break;\n\n        mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n        mergedGeometry.morphAttributes[name] = [];\n\n        for (let i = 0; i < numMorphTargets; ++i) {\n\n            const morphAttributesToMerge = [];\n\n            for (let j = 0; j < morphAttributes[name].length; ++j) {\n\n                morphAttributesToMerge.push(morphAttributes[name][j][i]);\n\n            }\n\n            const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge);\n\n            if (!mergedMorphAttribute) {\n\n                console.error('THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.');\n                return null;\n\n            }\n\n            mergedGeometry.morphAttributes[name].push(mergedMorphAttribute);\n\n        }\n\n    }\n\n    return mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes(attributes) {\n\n    let TypedArray;\n    let itemSize;\n    let normalized;\n    let arrayLength = 0;\n\n    for (let i = 0; i < attributes.length; ++i) {\n\n        const attribute = attributes[i];\n\n        if (attribute.isInterleavedBufferAttribute) {\n\n            console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.');\n            return null;\n\n        }\n\n        if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n\n            console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');\n            return null;\n\n        }\n\n        if (itemSize === undefined) itemSize = attribute.itemSize;\n        if (itemSize !== attribute.itemSize) {\n\n            console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');\n            return null;\n\n        }\n\n        if (normalized === undefined) normalized = attribute.normalized;\n        if (normalized !== attribute.normalized) {\n\n            console.error('THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');\n            return null;\n\n        }\n\n        arrayLength += attribute.array.length;\n\n    }\n\n    const array = new TypedArray(arrayLength);\n    let offset = 0;\n\n    for (let i = 0; i < attributes.length; ++i) {\n\n        array.set(attributes[i].array, offset);\n\n        offset += attributes[i].array.length;\n\n    }\n\n    return new BufferAttribute(array, itemSize, normalized);\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes(attributes) {\n\n    // Interleaves the provided attributes into an InterleavedBuffer and returns\n    // a set of InterleavedBufferAttributes for each attribute\n    let TypedArray;\n    let arrayLength = 0;\n    let stride = 0;\n\n    // calculate the the length and type of the interleavedBuffer\n    for (let i = 0, l = attributes.length; i < l; ++i) {\n\n        const attribute = attributes[i];\n\n        if (TypedArray === undefined) TypedArray = attribute.array.constructor;\n        if (TypedArray !== attribute.array.constructor) {\n\n            console.error('AttributeBuffers of different types cannot be interleaved');\n            return null;\n\n        }\n\n        arrayLength += attribute.array.length;\n        stride += attribute.itemSize;\n\n    }\n\n    // Create the set of buffer attributes\n    const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride);\n    let offset = 0;\n    const res = [];\n    const getters = ['getX', 'getY', 'getZ', 'getW'];\n    const setters = ['setX', 'setY', 'setZ', 'setW'];\n\n    for (let j = 0, l = attributes.length; j < l; j++) {\n\n        const attribute = attributes[j];\n        const itemSize = attribute.itemSize;\n        const count = attribute.count;\n        const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized);\n        res.push(iba);\n\n        offset += itemSize;\n\n        // Move the data for each attribute into the new interleavedBuffer\n        // at the appropriate offset\n        for (let c = 0; c < count; c++) {\n\n            for (let k = 0; k < itemSize; k++) {\n\n                iba[setters[k]](c, attribute[getters[k]](c));\n\n            }\n\n        }\n\n    }\n\n    return res;\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed(geometry) {\n\n    // Return the estimated memory used by this geometry in bytes\n    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n    // for InterleavedBufferAttributes.\n    let mem = 0;\n    for (const name in geometry.attributes) {\n\n        const attr = geometry.getAttribute(name);\n        mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n    }\n\n    const indices = geometry.getIndex();\n    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n    return mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nfunction mergeVertices(geometry, tolerance = 1e-4) {\n\n    tolerance = Math.max(tolerance, Number.EPSILON);\n\n    // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n    const hashToIndex = {};\n    const indices = geometry.getIndex();\n    const positions = geometry.getAttribute('position');\n    const vertexCount = indices ? indices.count : positions.count;\n\n    // next value for triangle indices\n    let nextIndex = 0;\n\n    // attributes and new attribute arrays\n    const attributeNames = Object.keys(geometry.attributes);\n    const attrArrays = {};\n    const morphAttrsArrays = {};\n    const newIndices = [];\n    const getters = ['getX', 'getY', 'getZ', 'getW'];\n\n    // initialize the arrays\n    for (let i = 0, l = attributeNames.length; i < l; i++) {\n\n        const name = attributeNames[i];\n\n        attrArrays[name] = [];\n\n        const morphAttr = geometry.morphAttributes[name];\n        if (morphAttr) {\n\n            morphAttrsArrays[name] = new Array(morphAttr.length).fill().map(() => []);\n\n        }\n\n    }\n\n    // convert the error tolerance to an amount of decimal places to truncate to\n    const decimalShift = Math.log10(1 / tolerance);\n    const shiftMultiplier = Math.pow(10, decimalShift);\n    for (let i = 0; i < vertexCount; i++) {\n\n        const index = indices ? indices.getX(i) : i;\n\n        // Generate a hash for the vertex attributes at the current index 'i'\n        let hash = '';\n        for (let j = 0, l = attributeNames.length; j < l; j++) {\n\n            const name = attributeNames[j];\n            const attribute = geometry.getAttribute(name);\n            const itemSize = attribute.itemSize;\n\n            for (let k = 0; k < itemSize; k++) {\n\n                // double tilde truncates the decimal value\n                hash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n            }\n\n        }\n\n        // Add another reference to the vertex if it's already\n        // used by another index\n        if (hash in hashToIndex) {\n\n            newIndices.push(hashToIndex[hash]);\n\n        } else {\n\n            // copy data to the new index in the attribute arrays\n            for (let j = 0, l = attributeNames.length; j < l; j++) {\n\n                const name = attributeNames[j];\n                const attribute = geometry.getAttribute(name);\n                const morphAttr = geometry.morphAttributes[name];\n                const itemSize = attribute.itemSize;\n                const newarray = attrArrays[name];\n                const newMorphArrays = morphAttrsArrays[name];\n\n                for (let k = 0; k < itemSize; k++) {\n\n                    const getterFunc = getters[k];\n                    newarray.push(attribute[getterFunc](index));\n\n                    if (morphAttr) {\n\n                        for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n\n                            newMorphArrays[m].push(morphAttr[m][getterFunc](index));\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            hashToIndex[hash] = nextIndex;\n            newIndices.push(nextIndex);\n            nextIndex++;\n\n        }\n\n    }\n\n    // Generate typed arrays from new attribute arrays and update\n    // the attributeBuffers\n    const result = geometry.clone();\n    for (let i = 0, l = attributeNames.length; i < l; i++) {\n\n        const name = attributeNames[i];\n        const oldAttribute = geometry.getAttribute(name);\n\n        const buffer = new oldAttribute.array.constructor(attrArrays[name]);\n        const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized);\n\n        result.setAttribute(name, attribute);\n\n        // Update the attribute arrays\n        if (name in morphAttrsArrays) {\n\n            for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n\n                const oldMorphAttribute = geometry.morphAttributes[name][j];\n\n                const buffer = new oldMorphAttribute.array.constructor(morphAttrsArrays[name][j]);\n                const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized);\n                result.morphAttributes[name][j] = morphAttribute;\n\n            }\n\n        }\n\n    }\n\n    // indices\n\n    result.setIndex(newIndices);\n\n    return result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry>}\n */\nfunction toTrianglesDrawMode(geometry, drawMode) {\n\n    if (drawMode === TrianglesDrawMode) {\n\n        console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');\n        return geometry;\n\n    }\n\n    if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n\n        let index = geometry.getIndex();\n\n        // generate index if not present\n\n        if (index === null) {\n\n            const indices = [];\n\n            const position = geometry.getAttribute('position');\n\n            if (position !== undefined) {\n\n                for (let i = 0; i < position.count; i++) {\n\n                    indices.push(i);\n\n                }\n\n                geometry.setIndex(indices);\n                index = geometry.getIndex();\n\n            } else {\n\n                console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');\n                return geometry;\n\n            }\n\n        }\n\n        //\n\n        const numberOfTriangles = index.count - 2;\n        const newIndices = [];\n\n        if (drawMode === TriangleFanDrawMode) {\n\n            // gl.TRIANGLE_FAN\n\n            for (let i = 1; i <= numberOfTriangles; i++) {\n\n                newIndices.push(index.getX(0));\n                newIndices.push(index.getX(i));\n                newIndices.push(index.getX(i + 1));\n\n            }\n\n        } else {\n\n            // gl.TRIANGLE_STRIP\n\n            for (let i = 0; i < numberOfTriangles; i++) {\n\n                if (i % 2 === 0) {\n\n                    newIndices.push(index.getX(i));\n                    newIndices.push(index.getX(i + 1));\n                    newIndices.push(index.getX(i + 2));\n\n                } else {\n\n                    newIndices.push(index.getX(i + 2));\n                    newIndices.push(index.getX(i + 1));\n                    newIndices.push(index.getX(i));\n\n                }\n\n            }\n\n        }\n\n        if ((newIndices.length / 3) !== numberOfTriangles) {\n\n            console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');\n\n        }\n\n        // build final geometry\n\n        const newGeometry = geometry.clone();\n        newGeometry.setIndex(newIndices);\n        newGeometry.clearGroups();\n\n        return newGeometry;\n\n    } else {\n\n        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);\n        return geometry;\n\n    }\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes(object) {\n\n    if (object.geometry.isBufferGeometry !== true) {\n\n        console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.');\n        return null;\n\n    }\n\n    const _vA = new Vector3();\n    const _vB = new Vector3();\n    const _vC = new Vector3();\n\n    const _tempA = new Vector3();\n    const _tempB = new Vector3();\n    const _tempC = new Vector3();\n\n    const _morphA = new Vector3();\n    const _morphB = new Vector3();\n    const _morphC = new Vector3();\n\n    function _calculateMorphedAttributeData(\n        object,\n        material,\n        attribute,\n        morphAttribute,\n        morphTargetsRelative,\n        a,\n        b,\n        c,\n        modifiedAttributeArray\n    ) {\n\n        _vA.fromBufferAttribute(attribute, a);\n        _vB.fromBufferAttribute(attribute, b);\n        _vC.fromBufferAttribute(attribute, c);\n\n        const morphInfluences = object.morphTargetInfluences;\n\n        if (material.morphTargets && morphAttribute && morphInfluences) {\n\n            _morphA.set(0, 0, 0);\n            _morphB.set(0, 0, 0);\n            _morphC.set(0, 0, 0);\n\n            for (let i = 0, il = morphAttribute.length; i < il; i++) {\n\n                const influence = morphInfluences[i];\n                const morph = morphAttribute[i];\n\n                if (influence === 0) continue;\n\n                _tempA.fromBufferAttribute(morph, a);\n                _tempB.fromBufferAttribute(morph, b);\n                _tempC.fromBufferAttribute(morph, c);\n\n                if (morphTargetsRelative) {\n\n                    _morphA.addScaledVector(_tempA, influence);\n                    _morphB.addScaledVector(_tempB, influence);\n                    _morphC.addScaledVector(_tempC, influence);\n\n                } else {\n\n                    _morphA.addScaledVector(_tempA.sub(_vA), influence);\n                    _morphB.addScaledVector(_tempB.sub(_vB), influence);\n                    _morphC.addScaledVector(_tempC.sub(_vC), influence);\n\n                }\n\n            }\n\n            _vA.add(_morphA);\n            _vB.add(_morphB);\n            _vC.add(_morphC);\n\n        }\n\n        if (object.isSkinnedMesh) {\n\n            object.boneTransform(a, _vA);\n            object.boneTransform(b, _vB);\n            object.boneTransform(c, _vC);\n\n        }\n\n        modifiedAttributeArray[a * 3 + 0] = _vA.x;\n        modifiedAttributeArray[a * 3 + 1] = _vA.y;\n        modifiedAttributeArray[a * 3 + 2] = _vA.z;\n        modifiedAttributeArray[b * 3 + 0] = _vB.x;\n        modifiedAttributeArray[b * 3 + 1] = _vB.y;\n        modifiedAttributeArray[b * 3 + 2] = _vB.z;\n        modifiedAttributeArray[c * 3 + 0] = _vC.x;\n        modifiedAttributeArray[c * 3 + 1] = _vC.y;\n        modifiedAttributeArray[c * 3 + 2] = _vC.z;\n\n    }\n\n    const geometry = object.geometry;\n    const material = object.material;\n\n    let a, b, c;\n    const index = geometry.index;\n    const positionAttribute = geometry.attributes.position;\n    const morphPosition = geometry.morphAttributes.position;\n    const morphTargetsRelative = geometry.morphTargetsRelative;\n    const normalAttribute = geometry.attributes.normal;\n    const morphNormal = geometry.morphAttributes.position;\n\n    const groups = geometry.groups;\n    const drawRange = geometry.drawRange;\n    let i, j, il, jl;\n    let group, groupMaterial;\n    let start, end;\n\n    const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);\n    const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);\n\n    if (index !== null) {\n\n        // indexed buffer geometry\n\n        if (Array.isArray(material)) {\n\n            for (i = 0, il = groups.length; i < il; i++) {\n\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));\n\n                for (j = start, jl = end; j < jl; j += 3) {\n\n                    a = index.getX(j);\n                    b = index.getX(j + 1);\n                    c = index.getX(j + 2);\n\n                    _calculateMorphedAttributeData(\n                        object,\n                        groupMaterial,\n                        positionAttribute,\n                        morphPosition,\n                        morphTargetsRelative,\n                        a, b, c,\n                        modifiedPosition\n                    );\n\n                    _calculateMorphedAttributeData(\n                        object,\n                        groupMaterial,\n                        normalAttribute,\n                        morphNormal,\n                        morphTargetsRelative,\n                        a, b, c,\n                        modifiedNormal\n                    );\n\n                }\n\n            }\n\n        } else {\n\n            start = Math.max(0, drawRange.start);\n            end = Math.min(index.count, (drawRange.start + drawRange.count));\n\n            for (i = start, il = end; i < il; i += 3) {\n\n                a = index.getX(i);\n                b = index.getX(i + 1);\n                c = index.getX(i + 2);\n\n                _calculateMorphedAttributeData(\n                    object,\n                    material,\n                    positionAttribute,\n                    morphPosition,\n                    morphTargetsRelative,\n                    a, b, c,\n                    modifiedPosition\n                );\n\n                _calculateMorphedAttributeData(\n                    object,\n                    material,\n                    normalAttribute,\n                    morphNormal,\n                    morphTargetsRelative,\n                    a, b, c,\n                    modifiedNormal\n                );\n\n            }\n\n        }\n\n    } else if (positionAttribute !== undefined) {\n\n        // non-indexed buffer geometry\n\n        if (Array.isArray(material)) {\n\n            for (i = 0, il = groups.length; i < il; i++) {\n\n                group = groups[i];\n                groupMaterial = material[group.materialIndex];\n\n                start = Math.max(group.start, drawRange.start);\n                end = Math.min((group.start + group.count), (drawRange.start + drawRange.count));\n\n                for (j = start, jl = end; j < jl; j += 3) {\n\n                    a = j;\n                    b = j + 1;\n                    c = j + 2;\n\n                    _calculateMorphedAttributeData(\n                        object,\n                        groupMaterial,\n                        positionAttribute,\n                        morphPosition,\n                        morphTargetsRelative,\n                        a, b, c,\n                        modifiedPosition\n                    );\n\n                    _calculateMorphedAttributeData(\n                        object,\n                        groupMaterial,\n                        normalAttribute,\n                        morphNormal,\n                        morphTargetsRelative,\n                        a, b, c,\n                        modifiedNormal\n                    );\n\n                }\n\n            }\n\n        } else {\n\n            start = Math.max(0, drawRange.start);\n            end = Math.min(positionAttribute.count, (drawRange.start + drawRange.count));\n\n            for (i = start, il = end; i < il; i += 3) {\n\n                a = i;\n                b = i + 1;\n                c = i + 2;\n\n                _calculateMorphedAttributeData(\n                    object,\n                    material,\n                    positionAttribute,\n                    morphPosition,\n                    morphTargetsRelative,\n                    a, b, c,\n                    modifiedPosition\n                );\n\n                _calculateMorphedAttributeData(\n                    object,\n                    material,\n                    normalAttribute,\n                    morphNormal,\n                    morphTargetsRelative,\n                    a, b, c,\n                    modifiedNormal\n                );\n\n            }\n\n        }\n\n    }\n\n    const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3);\n    const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3);\n\n    return {\n\n        positionAttribute: positionAttribute,\n        normalAttribute: normalAttribute,\n        morphedPositionAttribute: morphedPositionAttribute,\n        morphedNormalAttribute: morphedNormalAttribute\n\n    };\n\n}\n\n\n\nexport {\n    computeTangents,\n    mergeBufferGeometries,\n    mergeBufferAttributes,\n    interleaveAttributes,\n    estimateBytesUsed,\n    mergeVertices,\n    toTrianglesDrawMode,\n    computeMorphedAttributes,\n};","import * as THREE from 'three';\nimport * as BufferGeometryUtils from './BufferGeometryUtils.js';\n\nimport {\n    clamp,\n    lerp\n} from './math.js';\n\nconst DEG2RAD = Math.PI / 180;\n\nconst defaultOptions = {\n    bounceFactor: 0.03,\n    wobbleFactor: 10,\n    maxTranslation: 0.05,\n    maxRotationDegrees: 5 * DEG2RAD,\n    maxStretch: 1,\n};\n\nconst bsGeo = new THREE.SphereBufferGeometry(0.01);\nbsGeo.translate(0, -0.01 / 2, 0);\n\nconst bpGeo = new THREE.CylinderBufferGeometry(0, 0.01, 0.1, 4, 1);\nbpGeo.translate(0, 0.05, 0);\n\nconst boneGeo = BufferGeometryUtils.mergeBufferGeometries( [bsGeo, bpGeo] );\n\nboneGeo.rotateX(Math.PI / 2);\n\nconst helper = new THREE.Mesh(\n    new THREE.SphereGeometry(0.03),\n    new THREE.MeshBasicMaterial({\n        color: 'blue',\n        depthTest: false,\n        transparent: true,\n        visible: false,\n        toneMapped: false,\n    })\n);\nhelper.renderOrder = 999;\nconst helper2 = new THREE.Mesh(\n    boneGeo,\n    new THREE.MeshBasicMaterial({\n        color: 'yellow',\n        depthTest: false,\n        transparent: true,\n        opacity: 0.1,\n        visible: false,\n        toneMapped: false,\n    })\n);\nhelper2.renderOrder = 9999;\nconst helper3 = new THREE.Mesh(\n    new THREE.SphereGeometry(0.02),\n    new THREE.MeshBasicMaterial({\n        color: 'yellow',\n        depthTest: false,\n        transparent: true,\n        opacity: 0.1,\n        visible: false,\n        toneMapped: false,\n    })\n);\nhelper3.renderOrder = 999;\n\nconst animatedBoneWorldPosition = new THREE.Vector3();\nconst animatedBoneWorldRotation = new THREE.Quaternion();\nconst goalPosition = new THREE.Vector3();\nconst goalRotation = new THREE.Quaternion();\n\nclass WiggleBone {\n    constructor(target, options = {}) {\n        this.options = { ...defaultOptions,\n            ...options\n        };\n        this.target = target;\n        this.targetHelper = helper.clone();\n        if (options.scene) options.scene.add(this.targetHelper);\n        this.currentHelper = helper2.clone();\n        if (options.scene) options.scene.add(this.currentHelper);\n        this.currentHelper.add(helper3.clone());\n        this.currentHelper.children[0].position.y = -0.1;\n\n        this.originPosition = target.position.clone();\n        this.oldBoneWorldPosition = new THREE.Vector3();\n        this.oldBoneWorldRotation = new THREE.Quaternion();\n        this.target.getWorldPosition(this.oldBoneWorldPosition);\n        this.target.getWorldQuaternion(this.oldBoneWorldRotation);\n    }\n    reset() {\n        this.target.position.copy(this.originPosition);\n        this.target.updateMatrixWorld(true, false);\n        this.target.getWorldPosition(this.oldBoneWorldPosition);\n    }\n    update(dt) {\n        this.target.parent.updateMatrixWorld(true, false);\n\n        this.targetHelper.position.copy(this.originPosition);\n        this.target.parent.localToWorld(this.targetHelper.position);\n\n        // animatedBoneWorldPosition.copy(this.originPosition);\n        // this.target.localToWorld(animatedBoneWorldPosition);\n\n        // this.target.getWorldQuaternion(animatedBoneWorldRotation);\n\n        nlerpVectors(\n            goalPosition,\n            this.oldBoneWorldPosition,\n            this.targetHelper.position,\n            this.options.bounceFactor * dt\n        );\n        if (dt > 10) {\n            nlerpVectors(\n                goalPosition,\n                this.oldBoneWorldPosition,\n                this.targetHelper.position,\n                this.options.bounceFactor * dt\n            );\n        }\n\n        this.target.position.copy(goalPosition);\n        this.target.parent.worldToLocal(this.target.position);\n        this.oldBoneWorldPosition.copy(goalPosition);\n\n        const parentPosition = this.target.parent.getWorldPosition(\n            new THREE.Vector3()\n        );\n        this.currentHelper.position.copy(goalPosition);\n        this.currentHelper.updateMatrixWorld(true, false);\n\n        this.currentHelper.lookAt(parentPosition);\n\n        const lookAtPosition = this.currentHelper.children[0].getWorldPosition(\n            new THREE.Vector3()\n        );\n\n        const unit = this.target.position.clone();\n        unit.normalize();\n\n        this.target.up.set(0, 1, 0);\n\n        this.target.quaternion.setFromUnitVectors(this.target.up, unit);\n        let l = Math.min(this.target.position.length(), this.options.maxStretch);\n        this.target.position.set(0, l, 0);\n\n        this.target.updateMatrix();\n    }\n}\n\nconst aux = new THREE.Vector3();\nTHREE.Vector3.prototype.moveTowards = function(target, step) {\n    // newPos = startPos + (endPos - startPos).normalized * maxDist;\n    aux.copy(target).sub(this);\n    const l = aux.length();\n    const _s = clamp(step, 0, l);\n    aux.setLength(_s);\n    this.add(aux);\n};\n\nexport {\n    WiggleBone\n};\n\n//https://stackoverflow.com/questions/67919193/how-does-unity-implements-vector3-slerp-exactly\n\nconst relative = new THREE.Vector3();\n\nfunction slerpVectors(target, start, end, percent) {\n    // Dot product - the cosine of the angle between 2 vectors.\n    let dot = start.dot(end);\n    // console.log(dot);\n\n    // Clamp it to be in the range of Acos()\n    // This may be unnecessary, but floating point\n    // precision can be a fickle mistress.\n    dot = clamp(dot, -1.0, 1.0);\n\n    // Acos(dot) returns the angle between start and end,\n    // And multiplying that by percent returns the angle between\n    // start and the final result.\n    const theta = Math.acos(dot) * percent;\n\n    relative.copy(end);\n    relative.x -= start.x * dot;\n    relative.y -= start.y * dot;\n    relative.z -= start.z * dot;\n\n    relative.normalize();\n\n    // Orthonormal basis\n    // The final result.\n    const cosTheta = Math.cos(theta);\n    const sinTheta = Math.sin(theta);\n\n    target.x = start.x * cosTheta + relative.x * sinTheta;\n    target.y = start.y * cosTheta + relative.y * sinTheta;\n    target.z = start.z * cosTheta + relative.z * sinTheta;\n\n    return target;\n}\n\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nconst normalizedEnd = new THREE.Vector3();\n\nfunction nlerpVectors(target, start, end, percent) {\n    const lengthStart = start.length();\n    const lengthEnd = end.length();\n    normalizedEnd.copy(end).normalize();\n    target\n        .copy(start)\n        .normalize()\n        .lerp(normalizedEnd, percent)\n        .normalize()\n        .multiplyScalar(lerp(percent, lengthStart, lengthEnd));\n}","export function lerp(value, min, max) {\n    return min + value * (max - min);\n}\n\nexport function map(value, minA, maxA, minB, maxB, clamped = false) {\n    if (clamped)\n        value = Math.min(\n            Math.max(minA, maxA),\n            Math.max(Math.min(minA, maxA), value)\n        );\n    return ((value - minA) / (maxA - minA)) * (maxB - minB) + minB;\n}\n\nexport function clamp(value, min, max) {\n    return Math.min(max, Math.max(min, value));\n}\n\nexport function mod(value, length) {\n    return ((value % length) + length) % length;\n}","import * as THREE from \"three\"\nimport * as YUKA from 'yuka'\nimport { WiggleBone } from './utils/WiggleBones.js'\nimport { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'\nimport { EntityManager } from \"yuka\"\n\nconst sizes = {\n  width: window.innerWidth,\n  height: window.innerHeight\n}\nconst mouse = new THREE.Vector2()\nwindow.addEventListener('mousemove', (event) =>\n{\n    mouse.x = event.clientX / sizes.width * 2 - 1\n    mouse.y = - (event.clientY / sizes.height) * 2 + 1\n})\n\nconst canvas = document.querySelector('canvas')\nconst scene = new THREE.Scene()\n\nconst updateAllMaterials = (child, material) => {\n    child.traverse((child) => {\n        if (child.isMesh) {\n            child.material = material\n            child.castShadow = true\n        }\n    })\n}\n\nconst textureLoader = new THREE.TextureLoader()\nconst cubeTexureLoader = new THREE.CubeTextureLoader()\n\nconst environmentMap = cubeTexureLoader.load([\n  \"./textures/environmentMaps/cubeMap/px.jpg\",\n  \"./textures/environmentMaps/cubeMap/nx.jpg\",\n  \"./textures/environmentMaps/cubeMap/py.jpg\",\n  \"./textures/environmentMaps/cubeMap/ny.jpg\",\n  \"./textures/environmentMaps/cubeMap/pz.jpg\",\n  \"./textures/environmentMaps/cubeMap/nz.jpg\"\n])\n\nconst sceneBackgroundMaterial = new THREE.ShaderMaterial({\n    uniforms: {\n        turbidity: {\n            value: 2.5,\n        },\n        rayleigh: {\n            value: 2.7,\n        },\n        mieCoefficient: {\n            value: 0.218,\n        },\n        mieDirectionalG: {\n            value: 0.23,\n        },\n        elevation: {\n            value: -18,\n        },\n        azimuth: {\n            value: 0,\n        },\n        sunPosition: {\n            value: new THREE.Vector3(THREE.MathUtils.degToRad(90 - (-18)), THREE.MathUtils.degToRad(0), 1)\n        },\n        up: {\n            value: new THREE.Vector3(0, 1, 0)\n        },\n    },\n\n    vertexShader: /* glsl */ `\n\t\tuniform vec3 sunPosition;\n\t\tuniform float rayleigh;\n\t\tuniform float turbidity;\n\t\tuniform float mieCoefficient;\n\t\tuniform vec3 up;\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n\t\t// constants for atmospheric scattering\n\t\tconst float e = 2.71828182845904523536028747135266249775724709369995957;\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\t// wavelength of used primaries, according to preetham\n\t\tconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\n\t\t// this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:\n\t\t// (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))\n\t\tconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\n\n\t\t// mie stuff\n\t\t// K coefficient for the primaries\n\t\tconst float v = 4.0;\n\t\tconst vec3 K = vec3( 0.686, 0.678, 0.666 );\n\t\t// MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K\n\t\tconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\n\n\t\t// earth shadow hack\n\t\t// cutoffAngle = pi / 1.95;\n\t\tconst float cutoffAngle = 1.6110731556870734;\n\t\tconst float steepness = 1.5;\n\t\tconst float EE = 1000.0;\n\n\t\tfloat sunIntensity( float zenithAngleCos ) {\n\t\t\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n\t\t\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n\t\t}\n\n\t\tvec3 totalMie( float T ) {\n\t\t\tfloat c = ( 0.2 * T ) * 10E-18;\n\t\t\treturn 0.434 * c * MieConst;\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n      worldPosition.y *= -1.0;\n\t\t\tvWorldPosition = worldPosition.xyz;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position.z = gl_Position.w; // set z to camera.far\n\n\t\t\tvSunDirection = normalize( sunPosition );\n\n\t\t\tvSunE = sunIntensity( dot( vSunDirection, up ) );\n\n\t\t\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\n\t\t\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\n\t\t\t// extinction (absorbtion + out scattering)\n\t\t\t// rayleigh coefficients\n\t\t\tvBetaR = totalRayleigh * rayleighCoefficient;\n\n\t\t\t// mie coefficients\n\t\t\tvBetaM = totalMie( turbidity ) * mieCoefficient;\n\n\t\t}`,\n\n    fragmentShader: /* glsl */ `\n    #include <common>\n\n\t\tvarying vec3 vWorldPosition;\n\t\tvarying vec3 vSunDirection;\n\t\tvarying float vSunfade;\n\t\tvarying vec3 vBetaR;\n\t\tvarying vec3 vBetaM;\n\t\tvarying float vSunE;\n\n    vec3 dithering( vec3 color ) {\n  \t\tfloat grid_position = rand( gl_FragCoord.xy );\n  \t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n  \t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n  \t\treturn color + dither_shift_RGB;\n  \t}\n\n\t\tuniform float mieDirectionalG;\n\t\tuniform vec3 up;\n\n\t\tconst vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\n\n\t\t// constants for atmospheric scattering\n\t\tconst float pi = 3.141592653589793238462643383279502884197169;\n\n\t\tconst float n = 1.0003; // refractive index of air\n\t\tconst float N = 2.545E25; // number of molecules per unit volume for air at 288.15K and 1013mb (sea level -45 celsius)\n\n\t\t// optical length at zenith for molecules\n\t\tconst float rayleighZenithLength = 8.4E3;\n\t\tconst float mieZenithLength = 1.25E3;\n\t\t// 66 arc seconds -> degrees, and the cosine of that\n\t\tconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\n\n\t\t// 3.0 / ( 16.0 * pi )\n\t\tconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\n\t\t// 1.0 / ( 4.0 * pi )\n\t\tconst float ONE_OVER_FOURPI = 0.07957747154594767;\n\n\t\tfloat rayleighPhase( float cosTheta ) {\n\t\t\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n\t\t}\n\n\t\tfloat hgPhase( float cosTheta, float g ) {\n\t\t\tfloat g2 = pow( g, 2.0 );\n\t\t\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n\t\t\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec3 direction = normalize( vWorldPosition - cameraPos );\n\n\t\t\t// optical length\n\t\t\t// cutoff angle at 90 to avoid singularity in next formula.\n\t\t\tfloat zenithAngle = acos( max( 0.0, dot( up, direction ) ) );\n\t\t\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n\t\t\tfloat sR = rayleighZenithLength * inverse;\n\t\t\tfloat sM = mieZenithLength * inverse;\n\n\t\t\t// combined extinction factor\n\t\t\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\n\t\t\t// in scattering\n\t\t\tfloat cosTheta = dot( direction, vSunDirection );\n\n\t\t\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\t\t\tvec3 betaRTheta = vBetaR * rPhase;\n\n\t\t\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\t\t\tvec3 betaMTheta = vBetaM * mPhase;\n\n\t\t\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n\t\t\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\n\t\t\t// nightsky\n\t\t\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]\n\t\t\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]\n\t\t\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n\t\t\tvec3 L0 = vec3( 0.1 ) * Fex;\n\n\t\t\t// composition + solar disc\n\t\t\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\t\t\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\n\t\t\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\n\t\t\tvec3 retColor = pow( texColor, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\n\t\t\tgl_FragColor = vec4( retColor, 1.0 );\n\n      gl_FragColor.rgb += 0.05;\n      vec3 desaurated =  gl_FragColor.rgb / 0.21 * gl_FragColor.r + 0.71 * gl_FragColor.g + 0.07 * gl_FragColor.b;\n      desaurated -= 0.023;\n      gl_FragColor.rgb = mix(gl_FragColor.rgb, desaurated, 0.95);\n      gl_FragColor.rgb = dithering(gl_FragColor.rgb);\n\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\n\t\t}`,\n    side: THREE.BackSide,\n    depthWrite: false\n})\n\nconst sceneBackgroundGeometry = new THREE.BoxGeometry(20, 20, 20)\n\nconst sceneBackgound = new THREE.Mesh(sceneBackgroundGeometry, sceneBackgroundMaterial)\nsceneBackgound.scale.setScalar(100);\n\nscene.add(sceneBackgound)\n\nconst options = {\n  enableSwoopingCamera: false,\n  enableRotation: true,\n  transmission: 1,\n  thickness: 1.2,\n  roughness: 0.05,\n  envMapIntensity: 1.5,\n  clearcoat: 1,\n  clearcoatRoughness: 0.1,\n  normalScale: 1,\n  clearcoatNormalScale: 0.3,\n  normalRepeat: 1,\n  bloomThreshold: 0.85,\n  bloomStrength: 0.5,\n  bloomRadius: 0.33\n}\n\nconst normalMapTexture = textureLoader.load(\"./textures/environmentMaps/normal.jpeg\")\nnormalMapTexture.wrapS = THREE.RepeatWrapping\nnormalMapTexture.wrapT = THREE.RepeatWrapping\nnormalMapTexture.repeat.set(options.normalRepeat, options.normalRepeat)\n\nconst material = new THREE.MeshPhysicalMaterial({\n  transmission: options.transmission,\n  thickness: options.thickness,\n  roughness: options.roughness,\n  // envMap: hdrEquirect,\n  envMap: environmentMap,\n  envMapIntensity: options.envMapIntensity,\n  clearcoat: options.clearcoat,\n  clearcoatRoughness: options.clearcoatRoughness,\n  normalScale: new THREE.Vector2(options.normalScale),\n  normalMap: normalMapTexture,\n  clearcoatNormalMap: normalMapTexture,\n  clearcoatNormalScale: new THREE.Vector2(options.clearcoatNormalScale)\n})\n\nconst gltfLoader = new GLTFLoader()\n\nconst entityManager = new YUKA.EntityManager();\n\nfunction sync(entity, renderComponent) {\n    renderComponent.matrix.copy(entity.worldMatrix);\n}\n\nconst helperGeometry = new THREE.ConeGeometry(0.6, 1, 3);\nhelperGeometry.translate(0, 0.51, 0)\nconst helperMaterial = new THREE.MeshNormalMaterial()\nconst helper = new THREE.Mesh(helperGeometry, helperMaterial)\nhelper.castShadow = true\nhelper.receiveShadow = true\nhelper.position.set(3, -1, 3)\nscene.add( helper );\n\nconst target = new YUKA.Vehicle()\ntarget.setRenderComponent(helper, sync)\ntarget.position.set(3, 0, 3)\ntarget.maxSpeed = 2\nentityManager.add(target)\n\nlet mascot, mascotSteerer, rootBone, wiggleBones\nlet mascotLoaded = false\n\n// gltfLoader.load('./models/index.gltf', (gltf) => {\ngltfLoader.load('./models/fork.glb', (gltf) => {\n    const mesh = gltf.scene.children[0]\n    mesh.position.set(0, 3, 0);\n    // mascot = scene.getObjectByName(\"MascotSkinned\")\n    scene.add(mesh)\n\n    mascot = scene.getObjectByName(\"Fork\")\n\n    updateAllMaterials(mascot, material)\n\n    rootBone = mascot.children.find((c) => c.isBone);\n\n    mascotSteerer = new YUKA.Vehicle();\n    mascotSteerer.setRenderComponent(rootBone, sync);\n    mascotSteerer.maxSpeed = 3\n    \n    entityManager.add(mascotSteerer)\n    \n    const seekBehavior = new YUKA.SeekBehavior(target.position)\n    const pursuitBehavior = new YUKA.PursuitBehavior(target, 1);\n    mascotSteerer.steering.add(pursuitBehavior)\n    \n    wiggleBones = [];\n    rootBone.traverse((obj) => {\n        if (obj.name === 'Root') return;\n        if ((obj.isBone && obj.name.match('Leg')) || obj.name.match('Head')) {\n            const options = obj.name.match('Head') ?\n                {\n                    bounceFactor: 10,\n                    maxStretch: 1\n                } :\n                {\n                    bounceFactor: 5,\n                    maxStretch: 1.1\n                };\n            wiggleBones.push(\n                new WiggleBone(obj, { ...options, scene: scene})\n            );\n        }\n    });\n\n    mascotLoaded = true\n}\n)\n\nconst ambientLight = new THREE.AmbientLight(0x606575, 0.4);\n\nconst light = new THREE.DirectionalLight(0xffffff, 1);\nlight.position.set(45, 12, 20)\nlight.castShadow = true\nlight.receiveShadow = true\nlight.shadow.mapSize.width = 2048\nlight.shadow.mapSize.height = 2048\nlight.shadow.camera.top = 10\nlight.shadow.camera.left = -15\nlight.shadow.camera.right = 15\nlight.shadow.camera.bottom = -10\nlight.shadow.camera.near = 0.5\nlight.shadow.camera.far = 200\n\nconst lightHelper = new THREE.DirectionalLightHelper(light)\nconst lightShadowsHelper = new THREE.CameraHelper(light.shadow.camera)\nlightShadowsHelper.visible = true\n\nscene.add(ambientLight, light)\n\nconst floorGeometry = new THREE.PlaneGeometry( 20, 20, 32, 32 );\nconst floorMaterial = new THREE.MeshStandardMaterial({\n    color: 0x292b33,\n    side: THREE.DoubleSide\n})\nconst floor = new THREE.Mesh(floorGeometry, floorMaterial);\nfloor.position.set(0, -1, 0)\nfloor.rotation.x = -Math.PI * 0.5\nfloor.receiveShadow = true;\nscene.add(floor);\n\nconst camera = new THREE.PerspectiveCamera(20, sizes.width / sizes.height, 0.1, 100)\ncamera.position.set(30, 10, 30)\ncamera.rotation.x = Math.PI / 4\nscene.add(camera)\n\n// Controls\nconst controls = new OrbitControls(camera, canvas)\ncontrols.enableDamping = true\ncontrols.maxPolarAngle = Math.PI / 2\ncontrols.enableZoom = false\n\nconst renderer = new THREE.WebGLRenderer({\n    canvas: canvas,\n    antialiased: false,\n    logarithmicDepthBuffer: true,\n    powerPreference: \"high-performance\"\n})\nrenderer.setClearColor(0x000000, 1);\nrenderer.setSize(sizes.width, sizes.height)\nrenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\nrenderer.physicallyCorrectLights = true\nrenderer.outputEncoding = THREE.sRGBEncoding;\nrenderer.setSize(sizes.width, sizes.height)\nrenderer.shadowMap.type = THREE.PCFSoftShadowMap\nrenderer.shadowMap.enabled = true\n\nconst raycaster = new THREE.Raycaster()\n\nwindow.addEventListener('resize', () =>\n{\n    sizes.width = window.innerWidth\n    sizes.height = window.innerHeight\n\n    camera.aspect = sizes.width / sizes.height\n    camera.updateProjectionMatrix()\n\n    renderer.setSize(sizes.width, sizes.height)\n    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))\n})\n\nconst clock = new THREE.Clock()\nlet oldElapsedTime = 0\n\nconst tick = () => {\n    const elapsedTime = clock.getElapsedTime()\n    const deltaTime = elapsedTime - oldElapsedTime\n    oldElapsedTime = elapsedTime\n\n    let floorIntersect = raycaster.intersectObject(floor)\n\n    raycaster.setFromCamera(mouse, camera)\n\n    entityManager.update(deltaTime)\n\n    if (mascotLoaded) {\n        if (floorIntersect.length > 0) {\n            target.position.copy(floorIntersect[0].point);\n            helper.position.copy(target.position)\n        }\n        rootBone.position.copy(mascotSteerer.position)\n        rootBone.rotation.y += 0.033\n        entityManager.update(deltaTime)\n        wiggleBones.forEach((wiggle, i) => {\n            wiggle.update(deltaTime);\n        });\n    }\n    \n    controls.update()\n    console.log(camera.position)\n    \n    renderer.render(scene, camera)\n\n    window.requestAnimationFrame(tick);\n}\n\ntick()"],"names":["mergeBufferAttributes","attributes","TypedArray","itemSize","normalized","arrayLength","i","length","attribute","isInterleavedBufferAttribute","console","error","undefined","array","constructor","offset","set","BufferAttribute","defaultOptions","bounceFactor","wobbleFactor","maxTranslation","maxRotationDegrees","Math","PI","maxStretch","bsGeo","THREE","translate","bpGeo","boneGeo","geometries","useGroups","isIndexed","index","attributesUsed","Set","Object","keys","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","BufferGeometry","geometry","attributesCount","name","has","push","size","userData","mergedUserData","count","position","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","setAttribute","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","BufferGeometryUtils","rotateX","helper","color","depthTest","transparent","visible","toneMapped","renderOrder","helper2","opacity","helper3","goalPosition","WiggleBone","target","options","this","targetHelper","clone","scene","add","currentHelper","children","y","originPosition","oldBoneWorldPosition","oldBoneWorldRotation","getWorldPosition","getWorldQuaternion","reset","copy","updateMatrixWorld","update","dt","parent","localToWorld","nlerpVectors","worldToLocal","parentPosition","lookAt","unit","normalize","up","quaternion","setFromUnitVectors","l","min","updateMatrix","aux","step","sub","_s","value","max","setLength","normalizedEnd","start","end","percent","lengthStart","lengthEnd","lerp","multiplyScalar","sizes","width","window","innerWidth","height","innerHeight","mouse","addEventListener","event","x","clientX","clientY","canvas","document","querySelector","textureLoader","environmentMap","load","sceneBackgroundMaterial","uniforms","turbidity","rayleigh","mieCoefficient","mieDirectionalG","elevation","azimuth","sunPosition","vertexShader","fragmentShader","side","depthWrite","sceneBackgroundGeometry","sceneBackgound","scale","setScalar","normalMapTexture","wrapS","wrapT","repeat","material","transmission","thickness","roughness","envMap","envMapIntensity","clearcoat","clearcoatRoughness","normalScale","normalMap","clearcoatNormalMap","clearcoatNormalScale","gltfLoader","GLTFLoader","entityManager","YUKA","sync","entity","renderComponent","matrix","worldMatrix","helperGeometry","helperMaterial","castShadow","receiveShadow","mascot","mascotSteerer","rootBone","wiggleBones","setRenderComponent","maxSpeed","mascotLoaded","gltf","mesh","getObjectByName","child","traverse","isMesh","updateAllMaterials","find","c","isBone","pursuitBehavior","steering","obj","match","ambientLight","light","shadow","mapSize","camera","top","left","right","bottom","near","far","floorGeometry","floorMaterial","floor","rotation","controls","OrbitControls","enableDamping","maxPolarAngle","enableZoom","renderer","antialiased","logarithmicDepthBuffer","powerPreference","setClearColor","setSize","setPixelRatio","devicePixelRatio","physicallyCorrectLights","outputEncoding","shadowMap","type","enabled","raycaster","aspect","updateProjectionMatrix","clock","oldElapsedTime","tick","elapsedTime","getElapsedTime","deltaTime","floorIntersect","intersectObject","setFromCamera","point","forEach","wiggle","log","render","requestAnimationFrame"],"sourceRoot":""}